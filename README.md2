1. [High level diagram](#high-level-diagram)
  1. [High level explanation of components](#high-level-explanation-of-components)
2. [Deliverables](#deliverables)
  1. [Deliverable G-01](#deliverable-g-01)
  2. [Deliverable G-02](#deliverable-g-02)
  3. [Deliverable G-03](#deliverable-g-03)
  4. [Deliverable G-04](#deliverable-g-04)
  5. [Deliverable G-05](#deliverable-g-05)
  6. [Deliverable G-06](#deliverable-g-06)
  7. [Deliverable G-07](#deliverable-g-07)
  8. [Deliverable G-08](#deliverable-g-08)
  9. [Deliverable G-09](#deliverable-g-09)
  10. [Deliverable G-10](#deliverable-g-10)
  11. [Deliverable G-11](#deliverable-g-11)
  12. [Deliverable G-12](#deliverable-g-12)
  13. [Deliverable G-13](#deliverable-g-13)
3. [Non-Functional Deliverables](#non-functional-deliverables)
  1. [Portability](#portability)
  2. [Performance](#performance)
  3. [Security](#security)
  4. [Ease of use](#ease-of-use)
  5. [Reliability](#reliability)
3. [Technical Documentation](#technical-documentation)
  1. [Hardware](#hardware)
      1. [Automated back up](#automated-back-up)
      2. [Power button](#power-button)
      3. [WiFi on/off button](#wifi-on/off-button)
  2. [Software](#software)
      1. [General System Information](#general-system-information)
      2. [Maintenance Accounts](#maintenance-accounts)
      3. [Webpage Serving](#webpage-serving)
      4. [Captive Portal](#captive-portal)
      5. [Voucher system](#voucher-system)
      6. [External Media Content](#external-media-content)



# High level diagram 

## High level explanation of components
The following description provides a high level view of the PFIS’s components and functionalities. 
For further detail and overview, we have added a separate list with the required deliverables and detailed technical documentation about specific subjects.

The PFIS is built up with several different components. The left part of the diagram above contains the internal technical architecture. 
In order to meet the requirements (described in detail at section deliverables ) we have implemented many configurations beyond the basic Pi configurations. 

To start with basic needs, we have configured one Pi as the main test environment. Working with multiple developers on one system brings the risk of system failure and corruption of data, and therefore we have created several scripts for automated backups. We have made extensive use of the IPtables to configure firewall rules and settings for the self build captive portal. A wireless access point has been set up to provide passengers the possibility to connect with the PFIS. The local DHCP server provides connected devices with a local IP address. When connected with the PFIS’s AP, all users are able to connect with the webpage hosted by the local web server. This webpage contains many functions like a product store, media library, flight information,  and a specific function where passengers could buy and redeem a voucher for internet access. The captive portal intercepts outbound internet connections by default, and adds the IP addresses of the specific devices that initiated that connection to the IPtables. As long the IP address of the specific device is being marked, all outbound traffic is being blocked. When a voucher is redeemed, the device’s IP address is removed from the IPtables and outbound traffic restrictions are resolved. We have created our own solution for the captive portal, since publicly available solutions did not match our requirements. We have made some notable decisions about the design of the web page. Implementing the different functions in the web page felt like building a web application. With this in mind we have altered the original design and created a unique web page. 

Our web page runs on the Apache2 web server, that makes use of Tomcat9 which in turn serves servlets and JavaServer-pages. This servlet allows for integration without any port numbers or error prone URLs. For the store, media library and voucher system to work properly, we have installed a MySQL database, which contains the store products, audio and video files, list of vouchers and a list of ordered items. Updating media content like movies and music is as easy as could be. A python script has been built to automatically check a (just) plugged in media specific USB-stick for new content. If found, the script initiates the transfer of these files to the local storage, and meta data is added to the MySQL database. Newly added content is immediately available in the media library. 

Moving to the right side of the diagram, the exterior of the raspberry Pi, three physical buttons have been mounted on the raspberry Pi’s hull. These buttons have been added to provide the cabin crew with the ability to easily perform operations like (re)starting the raspberry Pi and to turn on/off WiFi. By pressing a button, a python script that runs on the background ‘listens’ to a specific I/O, will execute one of the mentioned operations. We found these options the best and ‘easiest to perform’ operations for the cabin crew. The whole system is built with plug and play in mind. By connecting the power- and ethernet connection cable (connected to the plane’s satellite) to the Pi, the system is good to go.

# Deliverables

## Deliverable G-01
If someone wants to connect to the PFIS with their smart device, all they need to do is connect to the WiFi-Hotspot, called 'CaptivePortal-FYS'.
Afterwards, their device will recognize that it is indeed a Captive Portal and most likely open a browser to navigate to it.
Then, after reaching the page, there is no need for any authentication and the user can browse the website to his or her heart's content.

This is made possible by using iptables, DNS redirection and a lot of Apache2 config rules.
## Deliverable G-02
Not done.
## Deliverable G-03
When the user navigates to the store, they can select articles and order them. It's that easy.
This is done by using a repository to interface with the back-end Database (MariaDB). Mainly Java was used to create the logic behind this.
## Deliverable G-04
Users can enjoy a wide selection of media entertainment. There is an RSS feed, customized to fit the website's theme, where people can read news from nu.nl.
Also, a Music page with a custom built Playlist and 6 most popular categories. All fully functional.
*There is a video page, where users can watch Movies.*
*Audiobooks for those who enjoy it.*
This is made possible by a mixture of Java, JavaScript, jQuery, Python and Bash on the back-end and of course, MariaDB. For details, check the source files and below technical documentation.
## Deliverable G-05
*By using a HTML5 custom player, MediaElement, users are able to choose from a selection of subtitles, as long as they are declared in the database.*
## Deliverable G-06
*Six games are implemented and are able to be played by navigating to the Games page through the menu.One home-made game was built and the rest was open-source and unlicensed. These have all been implemented in their own way.*
## Deliverable G-07
By 'Getting' a voucher through the Voucher page, users can Redeem that very same voucher to receive internet access. A cost of $10 per hour will be shown to the user.

A Python script has been used for this and continually runs on the Raspberry Pi. It functions as a REST API and responds to calls from the servlet.
This also monitors when time has run out, or which people still have internet access, for example when the Pi resets or crashes.
## Deliverable G-08
To realize this, cookies have been implemented to track the users' state. Also, in other programs, like the Voucher system, people will regain internet access after a reset.
## Deliverable G-09
A button has been placed on the Raspberry Pi to allow for easy access to a reset. Cabin crew can press the button, system restarts, nothing has to be done further.
## Deliverable G-10
The same goes for this. A button stops WiFi. A btton starts WiFi. Nothing needs to be done further.
## Deliverable G-11
Cabin crew can insert a USB-Stick with media content on it, and it will automatically be added to the Web Application without any interaction.
As documented in below technical documentation, this is made possible with a Python and Bash script that copy and write to the database.
## Deliverable G-12
*Nothing here yet...*
## Deliverable G-13
The voucher system works as intended. See Deliverable G-07.

# Non-Functional Deliverables
## Portability
This system has been tested with MacBooks, iPhones, Android Phones, Firefox, Chrome, Opera, Internet Explorer, Edge.
All browsers that are HTML5 compliant will render the website and all mobile devices with a small viewport will have a responsive view.
## Performance
After stress testing with below script, we have concluded that the Raspberry Pi can easily handle >200 concurrent users.

<a href="https://cdn.discordapp.com/attachments/389816222990073857/455851602235097100/stress-test.gif">Video proof</a>.




```
#!/bin/bash

while true; do
        for i in {1..200};do
                curl -X GET localhost:8080/app/ > /dev/null 2>&1 &
                echo -n "$i..."
        done
        echo -e "\n"
done
```
## Security
There is no HTTPS connection to the Raspberry Pi, nor is there a password on the Access Point, as per the requirements.
However, it is secure to pass through to the open internet, through IPtables.
## Ease of use
As this is a subjective matter, this is hard to determine. We sincerely believe this application is easy to use, as demonstrated by our countless 
family members testing the web application. The menu is easy to navigate and is large and clear. The music player also makes it very clear
what to do.
## Reliability
After stress testing extensively with the aforementioned script, the system has kept running smoothly without any crashes.
Even if it does crash for some reason, maybe a flight crew member accidentally presses the reset button, the Pi will resume where it left off,
wherever that matters.

# Technical Documentation
## Hardware
### Raspberry Pi
#### Automated back up

To avoid loss of data and hard work effort, it is very important to implement scheduled backups. This is done with a cron-job, a tool implemented in Linux which enables scheduled tasks to be executed.

**Install ntfs-3g and create directory for mounting the external harddisk**

First we need to install ntfs-3g, this is an opensource-driver program which allows us to read, write and create NTFS-partitions. The command to get this done is as follows: 
```
Sudo apt install ntfs-3g
```

We now need to create a new directory to which the external HD will be mounted. This is done with the command: 
```
Sudo mkdir /mnt/backup
```
**Automount external harddisk**

Lsblk lists information about all available (or the specified) block devices. The lsblk command reads the sysfs filesystems and udev db to gather information. The command: 
```
Sudo lsblk -f
```

With -f added to the lsblk command, it outputs information about the Pi’s (external) filesystems.

The information we need from this command is the UUID of our connected external hard disk (used to store back-ups). The UUID can be thought of as a unique serial number, used as an identification for the storage device. In our case, the UUID for the Seagate Expansion Drive is ‘2886AC4586AC157A’. The /etc/fstab file (file systems table) is a system configuration file on Unix (and therefore also Linux) computer systems. It lists all available disk parititions and other types of file systems and data sources. The fstab file is read by the mount command, which is executed automatically at boot time.

As we obtained the UUID of the HD with the lsblk -f command, we are now able to create a entry in the /etc/fstab file which enables the Pi to automatically mount the external HDD after reboot. It is important to understand the format of this document, as this file is also used for booting the system. Altering the fstab file incorrectly could possibly result in a unbootable system. The format is as follows:

```
<file system> <dir> <type> <options> <dumps> <pass>

UUID=”2886AC4586AC157A” /mnt/backup ntfs-3g defaults,locale=en_US.utf8	0 0
```

Under file system (or device specification) we put the UUID of the external hard-disk. The directory, also referred to as mount point, points to the location where the HD is mounted. Type describes the type of file system being mounted. Under options, defaults enables the default options such as; rw, suid, dev, exec, etcetera. Locale=en_US.utf8 defines the native-language environment, in this case English for the US. Dump contains a number indicating whether and how often the file system needs to be backed up. In this case a 0, indicating the file system will never automatically back up, will suffice since the HD is the device on which other backups are stored. The pass number indicates the order in which the fsck program will check the devices for errors at boot time. Since we only use our HDD for backups, a 0 (do not check) would do the trick.

**Scheduled back-up with cronjobs**

A cron job is used for scheduled tasks. In this case, a cron job is configured to automatically back-up the Pi’s SD card (mmcblk0) on a daily basis at 03:00 AM. For this cronjob to work, a bash script is needed that is executable by Linux.

The picture below shows the first part of the script. #!/bin/bash notifies Linux it is a file that needs to executed. Below there, some variables are declared. The rest of the script is used to start backup. To add a cronjob, we need to edit the cronjob tab by using the following command
```
Sudo crontab -e
```
By inserting the line 0 3 * * * (meaning, back up this file every day at 03:00) /root/Scripts/backup-pi (pointer to the Script file), the raspberry-pi’s automated backup is now set and ready to go.
#####Script
####Power button
#####Script
####WiFi on/off button
#####Script

## Software
### General System Information
Running on Raspbian (based on Debian) - Stretch.
This system is lightweight and consumes little power. It has to be optimized because of a lack of computing power. Scaling this solution requires multiple devices load balanced, which is a topic for another day.
### Maintenance Accounts
Maintenance accounts will be created for those who need it. This includes accounts for the MySQL (MariaDB) server, and root access to Raspbian.
### Webpage Serving
Webpages are served by using Apache 2 to route certain requests to Tomcat 9, which is a Java servlet/JSP deployment container. 
This makes for a seamless integration without any port numbers or error-prone URLs.

**Apache 2**
Apache 2 was installed in the regular way, by using the Advanced Package Tool (APT). It can thus be uninstalled in the same manner (apt remove). 
Web pages are deployed by filling the /var/www folder, which is the HTML root for our current Apache 2 installation. As mentioned, MediaWiki has a symbolic link in this folder, which allows you to read this right now. 
Apache has been configured to Reverse Proxy requests to Tomcat 9. For reverse proxies to be enabled, certain packages had to be installed: 
```
$ sudo a2enmod proxy 
$ sudo a2enmod proxy_http
$ sudo a2enmod proxy_balancer
$ sudo a2enmod lbmethod_byrequests
$ sudo systemctl restart apache2
```
Next, there were a few lines that had to be added to a config file called 000-default.conf 
This file is placed in the current location: /etc/apache2/sites-available/000-default.conf 
When opening this file, you will notice these 3 lines.

```
# Tomcat 9 Integration
      ProxyPreserveHost On
      ProxyPass /tc http://127.0.0.1:8080/
      ProxyPassReverse /tc http://127.0.0.1:8080/ 
```

These are responsible for routing to Tomcat 9. 
PreserveHost makes sure the original host header will be sent with the HTML request, in case the back-end has to do something with that. 
ProxyPass forwards all requests to the root of the Tomcat socket (/).
ProxyPassReverse makes sure that if any redirects happen on Tomcat, these will not be passed on to the client. Instead, the client will be redirected to the proxy, which is Apache 2, in this case. 
This makes for a seamless experience. Right now, if one were to navigate to <hostname>/tc, he or she would be greeted by the Tomcat servlet in the root location. Chances are that the /tc you see in this documentation might differ slightly, and might be called something like fys. In that case, <hostname>/fys would route you to whatever is configured in the file.

Tomcat 9
Tomcat 9 has been downloaded using wget, instead of apt. Tomcat 8 apparently does not support Java 8, thus Tomcat 9 had to be installed to stay relevant. The file will be downloaded to the /opt/tomcat directory. This has been done with the following command.

```
$ wget http://www.hjsnetworks.net/apache/tomcat/tomcat-9/v9.0.6/bin/apache-#tomcat-9.0.6.tar.gz
```
After this, the downloaded archive had to be unpacked

```
$ tar -xzvf apache-tomcat-9.0.6.tar.gz
```
Next, a new user has to be added for Tomcat, a service account. This was done with the following command.

```
$ sudo useradd -rs /bin/false tomcat
```
The -r tag makes sure that it's a system account, and the -s tag makes sure that the default shell is /bin/false, to further the security of our system (we isolate the Tomcat account).

As you might have read already, we like to use symbolic links in the /opt/ directory to stay consistent throughout time and make the system easy to maintain. In this case, a symbolic link was made using the following command

```
$ ln -s /opt/tomcat/apache-tomcat-9.0.0.M21/ /opt/tomcat/tomcat-latest
```
These files and links all have root as owner at this point in time. The next command changes it (recursively) to Tomcat, so that Tomcat can run the service.

```
$ chown -R tomcat.tomcat /opt/tomcat/tomcat-latest /opt/tomcat/apache-tomcat-9.0.0.M21
```

```
Attention - Yet again, for maintainers, when updating Tomcat, 
           make sure to relink the Symbolic link 
           to the new foldername.  
To gracefully start Tomcat via the startup.sh script (and close it using the shutdown.sh script, both situated in the /bin/ folder inside the Tomcat folder) we have chosen to add a systemd script with an [Install] area, to automatically start Tomcat on boot. The scripts full pathname is: /etc/systemd/system/tomcat.service 
You can see the script there.
```
After that, the following commands were run:
```
$ systemctl daemon-reload //Reload the systemctl daemon to load the newly created tomcat.service
$ systemctl start tomcat // The file is called tomcat.service
$ systemctl enable tomcat //To enable Tomcat, as a system service, the [Install] area must be present in the service script
```
After this, check if Tomcat is listening on the correct port: Utility to investigate sockets, listening, numeric (or it'll say http_alt), TCP sockets

```
$ ss -lnt | grep -i 8080 
$ LISTEN 0 100 :::8080 :::*
```

This means Tomcat is listening quite nicely!

A couple of quick notes for maintainers: The startup script and executable catalina.sh are both located in /opt/tomcat/tomcat-latest/bin

Catalina is a codename for Tomcat and in this file are a couple of environment variables that store information for Tomcat. 
For example: $CATALINA_BASE, $JAVA_HOME, $CATALINA_HOME. 
These variables are configured in the startup script:

```vim /etc/systemd/system/tomcat.service`` 
There is an Environment= part here
### Captive Portal
The captive portal is created to serve the purpose of redirecting visitors to our homepage. After logging in and possibly claiming their voucher, they are able to freely surf the internet.

Packages and Software used
To create the Captive Portal on the Infrastructure side, only iptables was used.

To actually interface with the iptables configuration and add new users, a combination of bash scripts and Java was used.
Java was actually only used to interface with the back-end Bash scripts in this regard.

Configuration
To see the iptables configuration, run the command 'iptables-save' as root. Example output as of 22-04-2018:
```
# Generated by iptables-save v1.6.0 on Sat Apr 21 12:20:36 2018
*filter
:INPUT ACCEPT [2800:461677]
:FORWARD ACCEPT [5512:2255570]
:OUTPUT ACCEPT [3536:2164578]
:captivePortal - [0:0]
-A FORWARD -m mark --mark 0x63 -j DROP
COMMIT
# Completed on Sat Apr 21 12:20:36 2018
# Generated by iptables-save v1.6.0 on Sat Apr 21 12:20:36 2018
*nat
:PREROUTING ACCEPT [634:66946]
:INPUT ACCEPT [258:26184]
:OUTPUT ACCEPT [91:10093]
:POSTROUTING ACCEPT [61:6025]
-A PREROUTING -p tcp -m mark --mark 0x63 -m tcp --dport 80 -j DNAT --to-destination 192.168.0.1
-A PREROUTING -p udp -m mark --mark 0x63 -m udp --dport 53 -j DNAT --to-destination 192.168.0.1
-A PREROUTING -p tcp -m mark --mark 0x63 -m tcp --dport 53 -j DNAT --to-destination 192.168.0.1
-A POSTROUTING -o eth0 -j MASQUERADE
COMMIT
# Completed on Sat Apr 21 12:20:36 2018
# Generated by iptables-save v1.6.0 on Sat Apr 21 12:20:36 2018
*mangle
:PREROUTING ACCEPT [8032:2679793]
:INPUT ACCEPT [2436:418838]
:FORWARD ACCEPT [5512:2255570]
:OUTPUT ACCEPT [3218:2096448]
:POSTROUTING ACCEPT [8878:4374637]
:captivePortal - [0:0]
-A PREROUTING -i wlan0 -j captivePortal
-A captivePortal -m mac --mac-source AC:CF:85:39:C8:65 -j RETURN
-A captivePortal -j MARK --set-xmark 0x63/0xffffffff
COMMIT
# Completed on Sat Apr 21 12:20:36 2018 
```
During configuration, iptables was kept as simple as possible. Some main points that would require your attention as maintainer:
Every packet that comes in on wlan0 will jump to the captivePortal chain. The first rule in this captivePortal chain you will see is a MAC source rule.
This rule implies that the computer with this specific MAC address will jump OUT of the captivePortal chain and continue where it came from. This means, **highly important** that it will skip the marking rule. Thus, the packets from the above MAC address will not be marked.

The prerouting rules in the mangle subsection apply to the packets in a very early stage. Mangle is used to actually alter packets.
In this case the packets are marked with the value 0x63 (this was picked randomly). This obviously applies to every packet that'll go through the captive portal, except for devices whose MAC address is included in this section, as described above.

The POSTROUTING rules above are where the real magic happens. Every packet that is marked and outbound for port 80 will be redirected to localhost. Which means that all web browser packets that are not outbound for HTTPS will be processed by Apache2 on the local system.
We all know that most websites these days use HTTPS and many modern browsers include a list of common websites like www.google.com that won't even start with HTTP. They will immediately go for HTTPS, thus rendering the above rule useless.

This is why during configuration, DNS rules were included. All traffic marked and outbound for port 53 will be sent to the local system. On this local system, DNS will actually forward all requests for any website, to the local system. 
See below configuration rules (/etc/dnsmasq.conf):
```
interface=wlan0
dhcp-range=192.168.0.2,192.168.0.254,255.255.255.0,24h
# Pass these 2 dns servers to the clients (google)
dhcp-option=6,8.8.8.8,8.8.4.4
#Reroute everything to  this pi.
address=/#/192.168.0.1
#Make windows clients work.
address=/www.msftconnecttest.com/192.168.0.1
#Make android phones work
address=/gstatic.com/8.8.8.8
```
To expand this list, connect to the hotspot with a Windows 7 laptop, or a Macbook, and use Wireshark to check outgoing connections.
For example, msftconnecttest.com is a website that Win10 clients use to check for internet connectivity.

This was actually necessary for Windows 10 laptops to work. During Wireshark investigation, multiple checks were found. One of them is a check for DNS. Once all DNS requests and results were redirected to the local captive portal, and some other wizardy was done, Windows 10 finally showed up a nice browser with the captive portal page. 
See below Apache 2 configuration:
```
<VirtualHost *:80>
 # Include the /app/ to Tomcat redirection. Check the file:
 # /etc/apache2/mods-available/jk.conf AND
 #/etc/apache2/mod_jk/worker.properties
JkMountCopy On
 # Redirect root to /app/
RedirectMatch ^/$ /app/

RewriteEngine on
 # Rewrite url from Windows autostarted browser
RewriteCond %{HTTP_HOST} ^(www\.)?msftconnecttest\.com$ [NC]
RewriteRule ^/(.*)$ http://captiveportal.fys/$1 [R=301,L]
 # Change /redirect/ to /app/
RedirectMatch ^/redirect$ /app/
 # Mac/Apple (Further testing?)
RewriteCond %{HTTP_USER_AGENT} ^CaptiveNetworkSupport(.*)$ [NC]
RewriteCond %{HTTP_HOST} !^192.168.0.1$
RewriteRule ^(.*)$ http://192.168.0.1/[L,R=302]
 # Android (new?)
RedirectMatch 302 /generate_204 http://192.168.0.1/
 # Windows 10 and older
RedirectMatch 302 /connecttest.txt http://captiveportal.fys/
RedirectMatch 302 /ncsi.txt http://192.168.0.1/
ServerAdmin webmaster@localhost
DocumentRoot /var/www/html

ErrorLog ${APACHE_LOG_DIR}/error.log
CustomLog ${APACHE_LOG_DIR}/access.log combined
RewriteCond %{SERVER_NAME} =fys-teamsix.asuscomm.com
RewriteRule ^ https://%{SERVER_NAME}%{REQUEST_URI} [END,NE,R=permanent]
</VirtualHost>
```
As you can see in above configuration, I wrote a redirect rule to redirect connections made to a Windows connectivity-check website, to the local system.

Also, a redirectrule was written to redirect all connections to the root (/) to (/app). This will try to contact the Tomcat back-end through AJP13 mod_jk. The comments in above configuration will indicate where to look for more information.

Authentication
Authentication is done by logging in with credentials on the Captive Portal Dashboard. 
On the back-end, a user is added in iptables by adding their MAC address in the Mangle list, as described in the previous section.

Java is responsible for fetching the users IP address. ARP Translates this IP address to a MAC address.

### Voucher system
The voucher system consists of a back-end python script running as a REST API, which means that requests to it are done via HTML.
The script is located in /portal/tools and it's always running. As soon as the Raspberry Pi reboots, it will check if there are still any active vouchers, which it will then incorporate into the
iptables.
Below is the script
```python
#!/usr/bin/env python
# Author: Herman Bonnes
# This python script serves as a back-end API to get and redeem vouchers for internet-access.
# This is made for a project called Fasten your Seatbelts.
from flask import *
import threading
import os # do linux syscall
import datetime # allowed internet time
import random #random choice for guid
import string #get letters for guid
import mysql.connector as mariadb #db connection
import sys #syscommands (argv)
import re #Regular expressions
import json # json dump!

app = Flask(__name__)

# Deny external connections.
@app.before_request
def limit_remote_addr():
    if request.remote_addr != 'localhost' and request.remote_addr != '127.0.0.1':
        print("Illicit connection detected.")
        abort(403)

#Create cursor for db interactions
cnx = mariadb.connect(user='FYS', password='FYSteamSIX', database='fys_webapp', buffered=True, autocommit=True)
cursor = cnx.cursor()

#Grant internet access to  certain mac address
def GrantInternet(ip, mac):
    #PORT=80
    #os.system('sudo /portal/tools/rmtrack {} {}'.format(ip, PORT))
    os.system('sudo /sbin/iptables -t mangle -I captivePortal -m mac --mac-source {} -j RETURN'.format(mac))
    os.system("sudo bash -c 'sleep 2; sudo conntrack -D -s {}' & > /dev/null 2>&1".format(ip))
    os.system("sudo bash -c 'sleep 2; sudo conntrack -D -d {}' & > /dev/null 2>&1".format(ip))
    print("sudo bash -c 'sleep 5; sudo conntrack -D -s {}' &".format(ip))
    print("Granted internet access to user with IP: {} and MAC: {}.".format(ip, mac))
    return()

#Remove internet access from certain mac address
def DenyInternet(guid, mac):
    cursor.execute("UPDATE voucher SET removed='1' WHERE guid=%s", (guid,))
    os.system('sudo /sbin/iptables -t mangle -D captivePortal -m mac --mac-source {} -j RETURN'.format(mac))
    print("Voucher for user with MAC: {} has expired. Removing...".format(mac))
    return()

# Only run once, during boot.
# Check if vouchers are still valid, grant internet access if they are.
def CheckVouchers():
    cur_time = datetime.datetime.now()
    cursor.execute("SELECT ip, mac_address FROM voucher WHERE removed=0 and used=1")
    if not cursor.rowcount:
        return()
    for ip, mac_address in cursor:
        GrantInternet(ip, mac_address)
    return()
CheckVouchers()

#Run a timer to check whether or not vouchers have expired
def CheckExpiration():
    t = threading.Timer(60.0, CheckExpiration)
    t.daemon = True
    t.start()
    cur_time = datetime.datetime.now()
    cursor.execute("SELECT guid, end_time, mac_address FROM voucher WHERE removed=0 and used=1")
    if not cursor.rowcount:
        return()
    else:
        for guid, end_time, mac_address in cursor:
            if end_time != None:
                if cur_time > end_time:
                    DenyInternet(guid, mac_address)
    return()
CheckExpiration()

# Get a mac address from IP address
def GetMac(ip):
    mac = "0"
    f = os.popen('arp -a {}'.format(ip))
    arp = f.read()
    m = re.search("..:..:..:..:..:..", arp)
    if m != None:
        mac = m.group(0)
        return(mac)
    return(mac)
# Root path.
@app.route('/')
def index():
    return("Usage: /getVoucher/<duration>,, /redeemVoucher/<voucher>/<ip>", 400)

#Get a new voucher!
@app.route('/getVoucher/<duration>')
def GetVoucher(duration):
    if (re.match('^\d$', duration) != None):
guid= "".join( [random.choice(string.letters) for i in xrange(11)] )
        cursor.execute("INSERT INTO voucher (guid, duration) VALUES (%s,%s)", (guid, duration))
        #return(json.dumps({'guid': guid}), 200)
        return(guid, 200)
        print("Created voucher with GUID: {}.".format(guid))
    else:
        return(400)

@app.route('/redeemVoucher/<guid>/<ip>')
def RedeemVoucher(guid, ip):
    if (re.match("^[a-zA-Z]{11}$", guid) != None):
        cursor.execute("SELECT used FROM voucher WHERE guid=%s", (guid,))
        #Check if voucher exists
        if not cursor.rowcount:
            return("No such voucher.", 400)
        #Check if voucher has been used
        for result in cursor:
            m = re.search("[0-9]{1}", str(result))
            used = m.group(0)
            if used == '1':
                return("Voucher already redeemed.", 400)
        #Fetch duration
        cursor.execute("SELECT duration FROM voucher WHERE guid=%s", (guid,))
        for result in cursor:
            m = re.search("[0-9]{1}", str(result))
            duration = m.group(0)
        #Define start & endtime
        startTime = datetime.datetime.now()
        endTime = startTime + datetime.timedelta(hours=int(duration))
        #Insert mac and ip
        mac = GetMac(ip)
        if mac == "0":
            return("Incorrect IP, no MAC found.", 400)
        cursor.execute("UPDATE voucher SET ip=%s, mac_address=%s WHERE guid=%s", (ip, mac, guid))
        #Set times and used
        cursor.execute("UPDATE voucher SET start_time=%s, end_time=%s, used='1' WHERE guid=%s", (startTime, endTime, guid))
        #Grant Internetaccess
        GrantInternet(ip, mac)
        #return(json.dumps({'guid': guid}), 200)
        return(guid, 200)
    else:
        return("Incorrect voucher.", 400)


if __name__ == "__main__":
    app.run()
    
```
You can get a voucher and give a duration, and you can redeem a voucher, at which point it will actually be only valid for that amount of time.

### External Media Content
The flight crew can insert a USB-stick with media content on it. The files on the USB-stick have to be formatted as follows:

USB-stick name: KINGSTON

**Folder structure:**
```
/Movies/[Genre]/[Movie.mp4]
/Music/[Genre]/[Song.mp3 | Song.flac]
/Audiobooks/[Genre]/[Audiobook.mp3]
```
After inserting the stick, the content will automatically be added and visible on the WebApp.
Below detection script and python script take care of the logic.

**/portal/tools/usb-detect.sh**
```bash
#!/bin/bash
LOCKFILE=/portal/tools/lockfile.lck
MOVIESDIR=/media/pi/KINGSTON/Movies
while true; do
        if [ -d $MOVIESDIR ]; then
                if [ ! -f $LOCKFILE ]; then
                        echo "Started media-copy.py." > /portal/tools/log/usb-detect.log
                        /portal/tools/media-copy.py > /portal/tools/log/usb-detect.log 2>&1 &
                        echo "Created lockfile.lck." > /portal/tools/log/usb-detect.log
                        touch $LOCKFILE
                fi
        else
                [ -f $LOCKFILE ] && rm -f $LOCKFILE
        fi
        sleep 5;
done
```

**/portal/tools/copy-media.py**
```python
#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
import logging # duh
import PTN # Parse Torrent Name
import eyed3 # metadata
import mysql.connector as mariadb #DB
import os # File manipulation
import fnmatch # File regex match
import shutil # Copy command
# Set up logging
logger = logging.getLogger('media_copy')
logger.setLevel(logging.DEBUG)
fh = logging.FileHandler('/portal/tools/log/media-copy.log')
fh.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
logger.addHandler(fh)
logger.propagate = False
logger.info("Starting!")

# Initialize db and cursor
cnx = mariadb.connect(user='FYS', password='FYSteamSIX', database='fys_webapp', buffered=True, autocommit=True)
cursor = cnx.cursor()
# Definitions
importDirectory = "/media/pi/"
exportDirectory = "/opt/tomcat/tomcat-latest/webapps/app/assets/media/"
extensions = ["*.mp3", "*.mp4", "*.flac"]
artist = "Unknown Artist"
title = "Unknown Title"
# Find the correct mountpoint, has to contain a folder with the name "Movies"
for f1 in os.listdir("/media/pi/"):
    for f2 in os.listdir("/media/pi/"+f1):
        if f2 == "Movies":
            importDirectory += f1
logger.info("Import Directory: {} Export Directory: {} Extensions: {}".format(importDirectory, exportDirectory, extensions))

# Walk through the import directory and find files whose extension match those defined
# If they do match, get the category (music/video and genres)
# Then check to see if those directories exist in the target (/assets/media/)
# If they don't; create them, and copy the files.
for root, dirs, files in os.walk(importDirectory):
    for extension in extensions:
        for filename in fnmatch.filter(files, extension):
            # Remove single quotes and weird unicode misery...
            os.rename(os.path.join(root, filename), os.path.join(root, filename.replace("’", ""))); filename = filename.replace("’", "")
            os.rename(os.path.join(root, filename), os.path.join(root, filename.replace("'", ""))); filename = filename.replace("'", "")

            category = "/".join(root.split("/")[4:]) + "/"
            srcPath = os.path.join(root, filename)
            dstPath = exportDirectory + category
            if not os.path.isdir(dstPath):
                os.makedirs(dstPath)
                logger.info("Made directory: {}".format(dstPath))
            if not os.path.exists(dstPath + filename):
                print dstPath + filename
                shutil.copy2(srcPath, dstPath)
                logger.info("Copying {} to {}".format(srcPath, dstPath+filename))

            # SQL Wizardry:
            filepath = "assets/media/" + category + filename
            genre = category.split("/")[1]
            # Music
            if "Music" in category:
                audio = eyed3.load(srcPath.decode('utf-8'))
                artist = audio.tag.artist
                title = audio.tag.title
                try:
                    if artist is None:
                        artist = "Various Artists"
                    if title is None:
                        title = filename.split(".")[0]
                    cursor.execute("INSERT INTO Music (Title, Artist, Genre, Filepath) VALUES (%s, %s, %s, %s)", (title, artist, genre, filepath))
                    logger.info("Added music with artist: {} and title: {}".format(artist, title))
                except Exception as e:
                    logger.warning("Already in DB: {}, Title: {}, Artist: {}".format(filepath, title, artist))
            # Video
 if "Movie" in category:
                parsed = PTN.parse(filename)
                year = parsed["year"]
                title = parsed["title"]
                try:
                    cursor.execute("INSERT INTO Movie (Title, Year, Genre, Filepath) VALUES (%s, %s, %s, %s)", (title, year, genre, filepath))
                    logger.info("Adding movie with title: {} to DB.".format(title))
                except Exception as e:
                    logger.warning("Already in DB: {}, Title: {}, Artist: {}".format(filepath, title, artist))
            # Audiobooks. To be tested with actual files.
            if "Audiobook" in category:
                audio = eyed3.load(srcPath.decode('utf-8'))
                artist = audio.tag.artist
                title = audio.tag.title
                try:
                    cursor.execute("INSERT INTO Audiobook (Title, Artist, Genre, Filepath) VALUES (%s, %s, %s, %s)", (title, artist, genre, filepath))
                except Exception as e:
                    logger.warning("Already in DB: {}".format(filepath))
logger.info("All done.")
```



